### 设计模式六大原则

- 1 开闭原则：对内扩展，对内修改
- 2 里氏替换：任何一父类使用的地方都可以将父类替换成子类，程序的行为没有发生变化，是对开闭原则的补充
- 3 依赖倒转： 高层不应该依赖底层，两者应该依赖抽象， 抽象不依赖细节，细节依赖抽象
如果A类依赖B类，但A类不应该直接依赖B类，应该对B类进行抽象或者定义B类的接口
- 4 接口隔离原则：客户端不应该被迫依赖他不适用的方法，一个类对另一个类的依赖应该建立在最小的接口上
A类拥有a，b两个方法，B继承A，但只需要a方法，不需要b方法
将a方法抽象为接口a,b方法抽象为接口B，实现类需要使用哪些功能，即实现哪个接口
- 迪米特原则：只和直接朋友交谈，不跟陌生人说话，如果两个软件实体类无直接联系，那么不应该直接发生联系，可以通过第三方转发调用，从而降低类之间的耦合度
- 合成复用原则： 尽量使用组合或者聚合等关联关系来实现，其次才考虑使用继承来实现

### 抽象工厂
拥有生产多种类型产品的工厂来得到每个产品

1 抽象工厂AbstractFactory 用来定义工厂子类的具体实现 现在有一个消息,钉钉消息,短信消息等,获取可以处理消息的实现

![image-20220712215013552](D:\down_package\maven_work\myspringIoc\img\image-20220712215013552.png)

定义产品功能实现,提供接口模板,不同的消息有不同的实现,从具体工厂中获取具体实现

![image-20220712215227884](D:\down_package\maven_work\myspringIoc\img\image-20220712215227884.png)

具体产品:

![image-20220712215337718](D:\down_package\maven_work\myspringIoc\img\image-20220712215337718.png)

使用时,将抽象工厂进行注入,在运行时会有具体工厂实现,再从具体工厂中获取方法

![image-20220712215500156](D:\down_package\maven_work\myspringIoc\img\image-20220712215500156.png)

使用:

```java
       //运行时传入具体工厂 
	   SendClient sendClient = new SendClient(new DingDingMsgFactory());
	  //通过具体工厂来获取具体实现方法	
        MsgTemplate msgTemplate = sendClient.getAbstractFactory().msgTemplate();

        msgTemplate.send();
```

### 建造者模式

将产品本身和产品的创建过程分离,通过不同的建造者可以创建出不同的产品对象

主要角色: 抽象建造者,一类方法是buildPartX()，它们用于创建复杂对象的各个部件；另一类方法是getResult()，它们用于返回复杂对象

具体建造者,实现抽象建造者,创建具体对象,创建过程就在

产品,被构建的复杂对象,具体建造者创建该产品的内部表示并定义它的装配过程。

指挥者:指挥者与抽象建造者之间存在关联关系，可以在其construct()建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造。



