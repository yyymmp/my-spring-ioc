#### 高性能IO模型:

##### 为什么redis单线程快:

redis的网络IO和键值对读写是一个线程处理的,这也是对外提供存储服务的,但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。

为什么使用单线程,多线程下存在的共享资源问题

单线程为什么快:

1 基于内存,高效的数据结构,如哈希表,跳表 

2 采用了多路复用模型,可以在网络io中处理大量请求,无需轮询,FD上一旦有请求到达,就会触发相应的事件

#### 宕机了,避免数据丢失

##### 写后日志

aof:写后日志,redis先执行命令,再记录日志

好处: 记录日志时不需要检查语法,因为都是执行过的命令

在执行命令后进行日志记录,不会阻塞当前写操作

潜在风险:执行完命令写日志时发生宕机,就会有相关数据丢失风险

写日志虽然不会阻塞当前命令,但写日志也是发生在主线程里面的,可能会阻塞后面的写命令

##### 三种写回策略

1 同步  2 每秒  3 操作系统控制写回

随着执行命令越来越多,aof文件必然越来越大,带来性能问题

1 文件系统的限制,无法保存过大的文件

2 文件太大时,追加命令效率降低

3 宕机恢复时,文件太大,恢复很慢

##### 对应文件过大的重写机制

将多条命令合为一条命令,重写之后,日志会缩小,但是这是一个十分耗时的过程,不该阻塞主线程()

#### 宕机后,快速进行恢复

生成全量数据快照,提供两个命令来生成rdb save和bgsave

save在主线程中执行

bgsave会fork子进程专门进行全量快照

借助写时复制技术,进行快照时,数据不动,但若主线程需要更改数据,则拷贝一份数据,在此副本上进行修改,而原数据不变

虽然跟 AOF 相比，快照的恢复速度快，但是，快照的频率不好把握，如果频率太低，两次快照间一旦宕机，就可能有比较多的数据丢失。如果频率太高，又会产生额外开销

Redis 4.0 中提出了一个**混合使用 AOF 日志和内存快照**的方法。简单来说，内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。

#### 数据多了时应该增加内存还是应该增加实例

增加内存:实现简单,但存在潜在问题

当使用 RDB 对数据进行持久化时，如果数据量增加，需要的内存也会增加，主线程 fork 子进程时就可能会阻塞,纵向扩展受硬件和成本的限制

使用横向扩展的redis切片集群两个问题:

数据切片后，在多个实例之间如何分布？

客户端怎么确定想要访问的数据在哪个实例上？

##### 数据切片和实例的关系

Redis Cluster 方案采用哈希槽（Slot），来处理数据和实例之间的映射关系。在 Redis Cluster 方案中，一个切片集群共有 16384 个哈希槽，这些哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中。

映射过程:首先根据键值对的 key，按照CRC16 算法计算一个 16 bit 的值；然后，再用这个 16bit 值对 16384 取模，得到 0~16383 范围内的模数，每个模数代表一个相应编号的哈希槽。那么，这些哈希槽又是如何被映射到具体的 Redis 实例上的呢？

 1.使用 cluster create 创建集群可以平均把哈希槽分到各个实例，每个实例的哈希槽个数是 16384/N 个 

2.可以使用cluster addslots 根据不同实例的性能自定义不同实例哈希槽的个数

##### 客户端如何定位数据

在定位键值对数据时，它所处的哈希槽是可以通过计算得到的，这个计算可以在客户端发送请求时来执行。

##### redis如何应对并发访问

1.加锁

一个是，如果加锁操作多，会降低系统的并发访问性能；

第二个是，Redis 客户端要加锁时，需要用到分布式锁，而分布式锁实现复杂，需要用额外的存储系统来提供加解锁操作

2.原子操作

为了实现并发控制要求的临界区代码互斥执行，Redis 的原子操作采用了两种方法：

1 把多个操作在 Redis 中实现成一个操作，也就是单命令操作；

2 把多个操作写到一个 Lua 脚本中，以原子性方式执行单个 Lua 脚本。















