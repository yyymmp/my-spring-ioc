#### 高性能IO模型:

##### 为什么redis单线程快:

redis的网络IO和键值对读写是一个线程处理的,这也是对外提供存储服务的,但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。

为什么使用单线程,多线程下存在的共享资源问题

单线程为什么快:

1 基于内存,高效的数据结构,如哈希表,跳表 

2 采用了多路复用模型,可以在网络io中处理大量请求,无需轮询,FD上一旦有请求到达,就会触发相应的事件

#### 宕机了,避免数据丢失

##### 写后日志

aof:写后日志,redis先执行命令,再记录日志

好处: 记录日志时不需要检查语法,因为都是执行过的命令

在执行命令后进行日志记录,不会阻塞当前写操作

潜在风险:执行完命令写日志时发生宕机,就会有相关数据丢失风险

写日志虽然不会阻塞当前命令,但写日志也是发生在主线程里面的,可能会阻塞后面的写命令

##### 三种写回策略

1 同步  2 每秒  3 操作系统控制写回

随着执行命令越来越多,aof文件必然越来越大,带来性能问题

1 文件系统的限制,无法保存过大的文件

2 文件太大时,追加命令效率降低

3 宕机恢复时,文件太大,恢复很慢

##### 对应文件过大的重写机制

将多条命令合为一条命令,重写之后,日志会缩小,但是这是一个十分耗时的过程,不该阻塞主线程()

#### 宕机后,快速进行恢复

生成全量数据快照,提供两个命令来生成rdb save和bgsave

save在主线程中执行

bgsave会fork子进程专门进行全量快照

借助写时复制技术,进行快照时,数据不动,但若主线程需要更改数据,则拷贝一份数据,在此副本上进行修改,而原数据不变

虽然跟 AOF 相比，快照的恢复速度快，但是，快照的频率不好把握，如果频率太低，两次快照间一旦宕机，就可能有比较多的数据丢失。如果频率太高，又会产生额外开销

Redis 4.0 中提出了一个**混合使用 AOF 日志和内存快照**的方法。简单来说，内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。

#### 数据多了时应该增加内存还是应该增加实例

增加内存:实现简单,但存在潜在问题

当使用 RDB 对数据进行持久化时，如果数据量增加，需要的内存也会增加，主线程 fork 子进程时就可能会阻塞,纵向扩展受硬件和成本的限制

使用横向扩展的redis切片集群两个问题:

数据切片后，在多个实例之间如何分布？

客户端怎么确定想要访问的数据在哪个实例上？

##### 数据切片和实例的关系

Redis Cluster 方案采用哈希槽（Slot），来处理数据和实例之间的映射关系。在 Redis Cluster 方案中，一个切片集群共有 16384 个哈希槽，这些哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中。

映射过程:首先根据键值对的 key，按照CRC16 算法计算一个 16 bit 的值；然后，再用这个 16bit 值对 16384 取模，得到 0~16383 范围内的模数，每个模数代表一个相应编号的哈希槽。那么，这些哈希槽又是如何被映射到具体的 Redis 实例上的呢？

 1.使用 cluster create 创建集群可以平均把哈希槽分到各个实例，每个实例的哈希槽个数是 16384/N 个 

2.可以使用cluster addslots 根据不同实例的性能自定义不同实例哈希槽的个数

##### 客户端如何定位数据

在定位键值对数据时，它所处的哈希槽是可以通过计算得到的，这个计算可以在客户端发送请求时来执行。

##### redis如何应对并发访问

1.加锁

一个是，如果加锁操作多，会降低系统的并发访问性能；

第二个是，Redis 客户端要加锁时，需要用到分布式锁，而分布式锁实现复杂，需要用额外的存储系统来提供加解锁操作

2.原子操作

为了实现并发控制要求的临界区代码互斥执行，Redis 的原子操作采用了两种方法：

1 把多个操作在 Redis 中实现成一个操作，也就是单命令操作；

2 把多个操作写到一个 Lua 脚本中，以原子性方式执行单个 Lua 脚本。

#### 解决缓存一致性

对于读写缓存,需要对数据进行增删改,

同步直写策略：写缓存时，也同步写数据库，缓存和数据库中的数据一致；

异步写回策略：写缓存时不同步写数据库，等到数据从缓存中淘汰时，再写回数据库。使用这种策略时，如果数据还没有写回数据库，缓存就发生了故障，那么，此时，数据库就没有最新的数据了。

对于读写缓存来说,就需要使用同步直写策略

对于只读缓存,数据新增时直接新增数据库,**删改**时将缓存中数据标为无效,

**对于新增数据**,缓冲中没有数据,数据库中是最新数据,符合缓存一致性

**对于修改数据**,既要更新数据库,也要更新缓存,此时会出现缓存不一致性问题

1   删除redis 缓存成功 2. 此时其他线程读取数据，使得旧数据重新被刷入缓存 3. 数据库数据被更新

2 先更新数据库,再更新缓存,但删除缓存失败

解决:

重试机制:可以把要删除的缓存值或者是要更新的数据库值暂存到消息队列中（例如使用 Kafka 消息队列）。当应用没有能够成功地删除缓存值或者是更新数据库值时，可以从消息队列中重新读取这些值，然后再次进行删除或更新

情况一:先 删除缓存,后更新数据库

在线程 A 更新完数据库值以后，我们可以让它先 sleep 一小段时间，再进行一次缓存删除操作。 这段时间就是线程B读取数据再存入缓存的时间,因为此时线程B读取的是旧值,在sleep之后,让线程A进行删除消除掉这期间B线程写入的旧,这种方案叫做**延迟双删**

情况二: 先更新数据库,后删除缓存

更新数据库后,还未删除缓存,此时有其他线程读取缓存,则读取到旧值,此时若并发读取比较小,且旧值缓存很快被删除,业务影响较小

总结:使用先删除缓存,再更新数据库的方式,配合延迟双删应该是最好的解决方式











