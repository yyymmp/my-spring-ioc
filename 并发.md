### 并发容器

#### ConcurrentHashMap

##### 为什么hashmap数组长度是2的幂次方

找到 KEY 的位置在哈希表的哪个槽里面时,使用了位运算,``` hash(KEY) & (length - 1)```

如果长度是类似4,8,16这种,-1后的二进制全部是1,任何数与这样的数进行与运算,并且最后得到的数在这个范围内,最重要的是奇偶性都是不确定的,保证散列的均匀性

但如果长度是一个奇数,那么化成二进制后,-1后二进制最后一位必然是0,任何数和这样的数作与运算,所得的数最后一位都是0,必然是偶数,浪费数组空间的一半

同理,若长度是一个奇数 如6,-1后二进制的第二位永远是0,导致2号,3号下标都不可能有值

扩容时,两倍,长度还是2的幂次方

之前8 扩容后16 ,扩容时,数组要迁移,不需要重新hash 

```
扩容前  length = 8  hash值 length-1
  1101
& 0111
   101  下标5的位置
扩容后  length = 16  hash值 length-1 
  1101
& 1111
  1101  下标13的位置,就是原下标位置+扩容大小
```



#### 解决hash冲突的方式

扩容与数据结构两种方式解决

扩容机制:1.7版本中,是否达到阈值(负载因子0.75),是否产生hash冲突, 扩容后,再添加元素,添加元素时重新计算桶位置,扩容过程:使用头插法

```java
 void transfer(Entry[] newTable, boolean rehash) {
        int newCapacity = newTable.length;
        for (Entry<K,V> e : table) {//遍历同桶数组中的每一个桶
            while(null != e) {//顺序遍历某个桶的外挂链表
                Entry<K,V> next = e.next;//引用next
                if (rehash) {
                    e.hash = null == e.key ? 0 : hash(e.key);
                }
                int i = indexFor(e.hash, newCapacity);//找到新表的桶位置;原桶数组中的某个桶上的同一链表中的Entry此刻可能被分散到不同的桶中去了，有效的缓解了哈希冲突。
                e.next = newTable[i];//头插法插入新表中
                newTable[i] = e;
                e = next;
            }
        }
```

10->8->6   ==>  6->8->10

多线程下扩容数据迁移死循环问题:

线程1: e=10 next = 8 切换线程

线程2:使用头插法,执行,  e=8,next=10,但线程再一次调度回到线程一继续往下执行,此时环就形成了,环状单向链表



1.8版本中,先添加元素,加完之后判断是否达到阈值扩容

使用尾插法就行插入,迁移时如果是单向链表,那么将单向链表进行迁移,如果是红黑树,将双向链表进行迁移

1.8版本中维护了两套机制 先维护一个双向链表,再将这个双向链表进行树化(元素大于8时)

```java
    final void treeifyBin(Node<K,V>[] tab, int hash) {
        int n, index; Node<K,V> e;
        if (tab == null || (n = tab.length) < MIN_TREEIFY_CAPACITY)
            resize();
        else if ((e = tab[index = (n - 1) & hash]) != null) {
            TreeNode<K,V> hd = null, tl = null;
            //维护双向链表
            do {
        
                TreeNode<K,V> p = replacementTreeNode(e, null);
                if (tl == null)
                    hd = p;
                else {
                    p.prev = tl;
                    tl.next = p;
                }
                tl = p;
            } while ((e = e.next) != null);
            if ((tab[index] = hd) != null)
                //树化
                hd.treeify(tab);
        }
    }
```

数据迁移后,如果发现链表长度小于6.那么会将这个树退化为链表

多线程环境扩容操作下会有数据丢失问题,修复了jdk7的死循环问题,通过上面的分析，不难发现循环的产生是因为新链表的顺序跟旧的链表是完全相反的，所以只要保证建新链时还是按照原来的顺序的话就不会产生循环。

```java
if ((p = tab[i = (n - 1) & hash]) == null) // 如果没有hash碰撞则直接插入元素
              tab[i] = newNode(hash, key, value, null);
```

这是jdk1.8中HashMap中put操作的主函数， 注意第6行代码，如果没有hash碰撞则会直接插入元素。如果线程A和线程B同时进行put操作，刚好这两条不同的数据hash值一样，并且该位置数据为null，所以这线程A、B都会进入第6行代码中。假设一种情况，线程A进入后还未进行数据插入时挂起，而线程B正常执行，从而正常插入数据，然后线程A获取CPU时间片，此时线程A不用再进行hash判断了，问题出现：线程A会把线程B插入的数据给**覆盖**，发生线程不安全。

**为什么发生树化的个数是8?**

概率问题,一般来说单项链表达到八个且发生碰撞的几率非常小,这也符合泊松比,因为树化的过程是非常麻烦的,这样就避免了树化

```
* 0:    0.60653066
* 1:    0.30326533
* 2:    0.07581633
* 3:    0.01263606
* 4:    0.00157952
* 5:    0.00015795
* 6:    0.00001316
* 7:    0.00000094
* 8:    0.00000006
```





